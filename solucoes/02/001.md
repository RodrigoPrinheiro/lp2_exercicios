## Problema

1 - Considera o seguinte código:

```cs
class Program
{
    static void Main(string[] args)
    {
        int[] arrayOfInts = new int[] { 1, 2, 3, 4 };

        foreach (int i in arrayOfInts)
        {
            Console.WriteLine(i);
        }
    }
}
```

1. Converte o código apresentado para que faça uso explícito do
   [enumerador](https://docs.microsoft.com/dotnet/api/system.collections.generic.ienumerator-1)
   devolvido pelo _array_.
2. Qual é ou quais são as vantagens do uso de `foreach` sobre o uso
   explícito de enumeradores?
3. Qual é a interface que a classe
   [`array`](https://docs.microsoft.com/dotnet/api/system.array) implementa
   que a obriga a ter um método para devolver um enumerador? Esta
   implementação é direta ou através de outras interfaces intermédias? Se se
   verificar este último caso, indica essa hierarquia de interfaces.
4. Qual é o _design pattern_ que propõe esta forma de aceder sequencialmente
   aos elementos de um objeto agregado/coleção, independentemente da forma
   como o mesmo foi implementado.

## Soluções

### Solução 1

1 - Rescrever a fazer uso do enumerador devolvido pelo array.
```csharp
using System;
using System.Collections;

namespace Ex_1
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] arrayOfInts = new int[] { 1, 2, 3, 4 };
            IEnumerator intEnum = arrayOfInts.GetEnumerator();

            while (intEnum.MoveNext())
            {
                int i = (int)intEnum.Current;

                Console.WriteLine(i);
            }
        }
    }
}
```
2 - Ao usar o `foreach` em vez do uso explícito do enumerador estamos
a promover a independência do código a uma coleção específica. Da mesma forma
estamos a respeitar/reforçar princípios de programação como: princípio da
inversão de dependência, substituição de Liskov e o princípio de segregação de
interfaces.

3 - Podemos confirmar, através da api do .net core, que a classe array implementa
a interface `IList`, esta interface por sua vez estende `ICollection` e esta
então estende `IEnumerable` que obriga a implementar o método `GetEnumerator()`.

![DependênciasArray][#img1]

4 - O *Design Pattern* usado neste exemplo é o de Iterador.

[#img1]:001.png